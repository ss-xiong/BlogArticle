MySQL索引了解一下

 一般的应用系统，读写比例在10:1左右，而且插入操作和一般的更新操作很少出现性能问题，遇到最多的，也是最容易出问题的，还是一些复杂的查询操作，所以查询语句的优化显然是重中之重。

​       在数据量和访问量不大的情况下，mysql访问是非常快的，是否加索引对访问影响不大。但是当数据量和访问量剧增的时候，就会发现mysql变慢，甚至down掉，这就必须要考虑优化sql了，给数据库建立正确合理的索引，是mysql优化的一个重要手段。  

​       索引的目的在于提高查询效率，可以类比字典，如果要查“mysql”这个单词，我们肯定需要定位到m字母，然后从下往下找到y字母，再找到剩下的sql。如果没有索引，那么你可能需要把所有单词看一遍才能找到你想要的。除了词典，生活中随处可见索引的例子，如火车站的车次表、图书的目录等。它们的原理都是一样的，通过不断的缩小想要获得数据的范围来筛选出最终想要的结果，同时把随机的事件变成顺序的事件，也就是我们总是通过同一种查找方式来锁定数据。

​       在创建索引时，需要考虑哪些列会用于 SQL 查询，然后为这些列创建一个或多个索引。事实上，_**索引其实就是一种数据结构，能够帮我们快速检索数据库中的数据。常见的MySQL索引主要有两种：Hash索引和B+ Tree索引。具体使用哪种索引与设置有关，InnoDB引擎默认使用的是B+树**_。索引保存着主键或索引字段，以及一个能将每个记录指向实际表的指针。数据库用户是看不到索引的，它们只是用来加速查询的。数据库搜索引擎使用索引来快速定位记录。

​      INSERT 与 UPDATE 语句在拥有索引的表中执行会花费更多的时间，而SELECT 语句却会执行得更快。这是因为，在进行插入或更新时，数据库也需要插入或更新索引值。

#### 创建索引

索引的类型有：

* UNIQUE(唯一索引)：不可以出现相同的值，可以有NULL值
* INDEX(普通索引)：允许出现相同的索引内容
* PROMARY KEY(主键索引)：不允许出现相同的值
* fulltext index(全文索引)：可以针对值中的某个单词，但效率确实不敢恭维
* 组合索引：实质上是将多个字段建到一个索引里，列值的组合必须唯一



#### B+ Tree 和 Hash索引的优缺点比较

Hash索引底层数据结构是Hash表。Hash表是一种以key-value对存储数据的结构，所以多个数据在存储关系上是完全没有任何顺序关系的，所以对于区间查询无法直接通过索引查询的，就需要进行全表扫描。**所以，哈希索引只适用于等值查询的场景**。而B+树是一种多路平衡查询树，所以他的节点是天然有序的（左子节点小于父节点、父节点小于右子节点），所以对于范围查询的时候不需要做全表扫描。

B+Tree索引和Hash索引的区别：

* 哈希索引适合等值查询，但是无法进行范围查询
* 哈心索引没办法利用索引完成排序（天然无序）
* 哈希索引不支持多列联合索引的最左匹配规则
* 如果有大量重复键值的情况下，哈希索引的效率会很低，因为存在**哈希碰撞问题**



#### 索引的储存

索引B+Tree叶子节点存储的数据有可能是整行数据，也可能是主键的值。在InnoDB里，**索引B+Tree的叶子节点存储了整行数据的是主键索引**，也被称之为_**聚簇索引**_。而**索引B+Tree的叶子节点存储了主键的值的是非主键索引**，也被称之为_**非聚簇索引**_。

* 主键索引：主键索引树的叶子节点就是需要查询的整行数据，所以主键索引查询数据会更快。

* 非主键索引：非主键索引的叶子节点存储的是主键的值，查到值以后还需要回表通过主键值查询。**覆盖索引（convering index）**指一个查询语句的执行只用从索引中就能取得，不必从数据表中读取。也可称之为**索引覆盖**。也就是说**当一条查询语句符合覆盖索引条件时，MySQL只需要通过索引就可以返回查询所需要的数据，这样避免了查到索引后在返回表的操作，减少I/O提高效率**。

  例如：表 `convering_index_people` 中有一个普通索引 `idx_keyA_keyB(keyA, keyB)`。当通过SQL语句：`select keyB from covering_index_people where keyA = 'somekey'`的时候，就可以通过覆盖索引查询，无需回表。因为`keyB`就在索引中。



#### 最左前缀匹配原则

MySQL查询会遵循_**最左前缀匹配**_原则（即**最左优先**），在检索数据时从联合索引的最左边开始匹配。所以创建联合索引的时候，如（keyA，keyB，keyC），则相当于创建了(keyA)，（keyA，keyB），（keyA，keyB，keyC）三个索引。所以差创建联合索引时，where字句中使用最频繁的一列应该在最左边。



#### 查询优化器

一条SQL语句的查询，可以有不同的执行方案，至于最终选择哪种方案，需要通过**优化器**进行选择，选择执行成本最低的方案。在一条单表查询语句真正执行之前，MySQL的查询优化器会找出执行该语句所有可能使用的方案，对比之后找出成本最低的方案。这个成本最低的方案就是我们所说的执行计划。优化过程大致如下：

1. 根据搜索条件，找出所有可能使用的索引

 	2. 计算全表扫满的代价
 	3. 计算使用不同索引执行查询的代价
 	4. 对比各种执行方案的代价，找出成本最低的那一种



#### 索引执行计划

通过`explain`查看SQL语句的执行计划，通过执行计划分析索引使用情况



#### 索引下推(index condition pushdown)

MySQL5.6引入了索引下推优化，默认开启。使用`SET optimizer_switch = 'index_condition_pushdown=off';`可以将其关闭。官方文档中的例子和解释如下：

​	people表中(zipconde, lastname, firstname)构成一个索引。当执行`SELECT * FROM people WHERE zipcode = '12345' AND lastname LIKE '%etrunia%' AND firstname LIKE '%%Main Street'`查询语句时：

* 如果没有使用索引下推技术，则MySQL会通过zipcode='12335'从存储引擎中查询对应的数据，返回到MySQL服务端，然后MySQL服务端基于`lastname LIKE '%errunia%'`和`address LIKE '%Main street%'`来判断数据是否符合条件。
* 如果使用了索引下推技术，则MySQL首先会返回`zipcode='12345'`的索引，然后根据`lastname LIKE '%etrunia%'`和`address LIKE '%Main street%'`来判断索引是否符合条件。如果符合条件，则根据该索引来定位对应的数据，如果不符合，则直接reject掉。有了索引下推优化，可以在有LIKE条件查询的情况下，减少回表次数。